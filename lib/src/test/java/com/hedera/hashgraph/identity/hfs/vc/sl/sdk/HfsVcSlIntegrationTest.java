/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.hedera.hashgraph.identity.hfs.vc.sl.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.*;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.concurrent.TimeoutException;

import static org.junit.jupiter.api.Assertions.*;

@Tag("integration")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class HfsVcSlIntegrationTest {
    private static final Client client = Client.forTestnet();
    private static final PrivateKey fileKey = PrivateKey.generateED25519();
    private static FileId fileId = null;
    private static final String CONFIG_FILE = "config.properties";

    @BeforeAll
    public static void setup() {
        try (InputStream input = HfsVcSlIntegrationTest.class.getClassLoader().getResourceAsStream(CONFIG_FILE)) {

            Properties prop = new Properties();

            if (input == null) {
                System.out.println("Sorry, unable to find config.properties");
                return;
            }

            //load a properties file from class path, inside static method
            prop.load(input);

            AccountId operatorId = AccountId.fromString(prop.getProperty("OPERATOR_ID"));
            PrivateKey operatorKey = PrivateKey.fromString(prop.getProperty("OPERATOR_KEY"));
            client.setOperator(operatorId, operatorKey);

            HfsVcSlIntegrationTest.fileId = new HfsVcSl(HfsVcSlIntegrationTest.client, HfsVcSlIntegrationTest.fileKey).createRevocationListFile();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    /**
     * #createRevocationListFile
     */

    @Test
    @Order(111)
    @DisplayName("creates a revocation list on HFS")
    void itCreatesRevocationList() throws PrecheckStatusException, TimeoutException {
        FileContentsQuery query = new FileContentsQuery().setFileId(HfsVcSlIntegrationTest.fileId);
        ByteString encodedStatusList = query.execute(HfsVcSlIntegrationTest.client);
        assertTrue(encodedStatusList.toStringUtf8().startsWith("H4sIAAAAAA"));
        assertEquals(64, encodedStatusList.size());
    }

    /**
     * #loadRevocationList
     */

    @Test
    @Order(211)
    @DisplayName("loads file and returns a status list")
    void itLoadsStatusListFileContent() throws PrecheckStatusException, TimeoutException, IOException {
        HfsVcSl hfsVcSl = new HfsVcSl(HfsVcSlIntegrationTest.client, HfsVcSlIntegrationTest.fileKey);
        RevocationList list = hfsVcSl.loadRevocationList(HfsVcSlIntegrationTest.fileId);

        assertEquals(100032, list.getSize());

        for (int i = 0; i < 100032; i++) {
            assertFalse(list.isRevoked(i));
        }
    }

    /**
     * Change credential status by index
     */

    @Test
    @Order(311)
    @DisplayName("should apply revoked status to revocation list index 0")
    void itSetsCredentialStatusToRevoked() throws Exception {
        HfsVcSl hfsVcSl = new HfsVcSl(HfsVcSlIntegrationTest.client, HfsVcSlIntegrationTest.fileKey);
        hfsVcSl.revokeByIndex(HfsVcSlIntegrationTest.fileId, 0);
        VcSlStatus status = hfsVcSl.resolveStatusByIndex(HfsVcSlIntegrationTest.fileId, 0);
        assertEquals(VcSlStatus.REVOKED, status);
    }

    @Test
    @Order(312)
    @DisplayName("should apply suspended status to revocation list index 0")
    void itSetsCredentialStatusToSuspended() throws Exception {
        HfsVcSl hfsVcSl = new HfsVcSl(HfsVcSlIntegrationTest.client, HfsVcSlIntegrationTest.fileKey);
        hfsVcSl.suspendByIndex(HfsVcSlIntegrationTest.fileId, 0);
        VcSlStatus status = hfsVcSl.resolveStatusByIndex(HfsVcSlIntegrationTest.fileId, 0);
        assertEquals(VcSlStatus.SUSPENDED, status);
    }

    @Test
    @Order(313)
    @DisplayName("should apply resumed status to revocation list index 0")
    void itSetsCredentialStatusToResumed() throws Exception {
        HfsVcSl hfsVcSl = new HfsVcSl(HfsVcSlIntegrationTest.client, HfsVcSlIntegrationTest.fileKey);
        hfsVcSl.resumeByIndex(HfsVcSlIntegrationTest.fileId, 0);
        VcSlStatus status = hfsVcSl.resolveStatusByIndex(HfsVcSlIntegrationTest.fileId, 0);
        assertEquals(VcSlStatus.RESUMED, status);
    }

    @Test
    @Order(314)
    @DisplayName("should apply active status to revocation list index 0")
    void itSetsCredentialStatusToActive() throws Exception {
        HfsVcSl hfsVcSl = new HfsVcSl(HfsVcSlIntegrationTest.client, HfsVcSlIntegrationTest.fileKey);
        hfsVcSl.issueByIndex(HfsVcSlIntegrationTest.fileId, 0);
        VcSlStatus status = hfsVcSl.resolveStatusByIndex(HfsVcSlIntegrationTest.fileId, 0);
        assertEquals(VcSlStatus.ACTIVE, status);
    }

    @Test
    @Order(315)
    @DisplayName("should throw an error when index is not multiple of 2 or 0")
    void invalidIndex() {
        var errorMsg = "vcStatusListIndex must be Multiples of 2 OR 0. e.g. 0, 2, 4, 6, 8, 10, 12, 14";
        HfsVcSl hfsVcSl = new HfsVcSl(HfsVcSlIntegrationTest.client, HfsVcSlIntegrationTest.fileKey);
        Assertions.assertThrowsExactly(Error.class, () -> hfsVcSl.resumeByIndex(HfsVcSlIntegrationTest.fileId, 5), errorMsg);
        Assertions.assertThrowsExactly(Error.class, () -> hfsVcSl.revokeByIndex(HfsVcSlIntegrationTest.fileId, 5), errorMsg);
        Assertions.assertThrowsExactly(Error.class, () -> hfsVcSl.suspendByIndex(HfsVcSlIntegrationTest.fileId, 5), errorMsg);
        Assertions.assertThrowsExactly(Error.class, () -> hfsVcSl.issueByIndex(HfsVcSlIntegrationTest.fileId, 5), errorMsg);

    }
}
